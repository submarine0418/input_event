Here is a detailed code review, structural explanation, and a complete `README.md` file for your project.

### Code Review & Structure Analysis

This code implements a **Linux TTY Line Discipline (LDISC)**.
*   **Concept:** A Line Discipline sits between the low-level hardware driver (USB/UART) and the high-level user space. It acts as a filter or a translator.
*   **Your Goal:** Translate raw serial bytes (`W1\n`) into Kernel Input Events (Key presses).

#### 1. The Data Structure (`struct swd_dev`)
This acts as the "object" for each connected joystick.
*   **`tty`**: A reference back to the serial port so we can change settings.
*   **`input`**: The virtual keyboard device we create to talk to the OS.
*   **`lock`**: A "Spinlock". This is crucial because `receive_buf` runs in an **interrupt context** (very fast, cannot sleep). The lock prevents two CPU cores from messing up the buffer at the same time.
*   **`buf`**: A small waiting room for characters until a `\n` arrives.

#### 2. The Parser (`swd_parse_line`)
This is the logic engine.
*   It filters out the heartbeat dot (`.`).
*   It reads the first char (`W`) and the second char (`1` or `0`).
*   It calls `input_report_key` to tell the Linux Input Subsystem "The W key is now down".
*   `input_sync` tells the OS "I am done reporting for this moment, process the events now."

#### 3. The Setup (`swd_open`)
This is the most complex part, where we solved the "Silence" bug.
1.  **Allocation:** Creates memory for the struct and the input device.
2.  **Registration:** Tells Linux "I am a keyboard named serial-wasd".
3.  **`tty->receive_room = 65536`**: **CRITICAL.** By default, a custom driver has 0 room. This line opens the floodgates so the kernel pushes data to us.
4.  **`tty_set_termios`**: **CRITICAL.** This forces the USB hardware to switch to "Raw Mode" (no echo, no processing) and "CLOCAL" (ignore modem control lines). Without this, the hardware waits for a signal that never comes.

#### 4. The Data Handler (`swd_receive_buf`)
This function is called by the kernel whenever the USB chip receives data.
*   It grabs the spinlock for safety.
*   It loops through received bytes.
*   It buffers them until it sees `\n`, then calls the parser.
*   *Note:* The `pr_info` debug line is currently active here, which is good for testing but should be removed for production.

#### 5. The Registration (`swd_init` / `swd_exit`)
*   Uses the **Kernel 6.12 API**.
*   Registers the discipline number `29`.
*   When you run `ldattach`, it looks up number 29 and finds this structure.

---

### README.md

Here is the file content. You can save this as `README.md` in your folder.

```markdown
# WASD Serial Line Discipline (Kernel Driver)

This project implements a custom Linux Kernel TTY Line Discipline (LDISC number 29). It converts serial data received from an Arduino joystick into native Linux Keyboard Events.

This allows an Arduino to act as a hardware keyboard driver at the kernel level, working with games, terminals, and X11 without requiring user-space scripts.

## Features
- **Kernel Space Performance:** Zero latency input handling.
- **Hot-pluggable:** Works with standard `ldattach` utilities.
- **Robustness:** Handles device disconnects and memory safety.
- **Kernel 6.12 Ready:** Updated for the latest Linux TTY APIs.

## Hardware Requirements
- Raspberry Pi (running Kernel 6.x+)
- Arduino (Uno, Nano, or similar)
- Analog Joystick Module

## Arduino Protocol
The Arduino must send data in the following format at **9600 baud**:
- `W1` + `\n` : W Key Pressed
- `W0` + `\n` : W Key Released
- `.` + `\n`  : Heartbeat (sent every 1s to keep connection alive)

## Installation

### 1. Build the Module
Ensure you have kernel headers installed, then compile:
```bash
make
```

### 2. Install the Module
Copy the compiled driver to the system drivers folder and update dependencies:
```bash
sudo cp serial_wasd_ldisc.ko /lib/modules/$(uname -r)/kernel/drivers/tty/
sudo depmod -a
```

### 3. Load the Module
```bash
sudo modprobe serial_wasd_ldisc
```
*(Optional) To load on boot, add `serial_wasd_ldisc` to modules.*

## Usage

### 1. Connect the Arduino
Plug in your Arduino. Check `dmesg | tail` to find the port (e.g., ttyACM0).

### 2. Attach the Driver
Use `ldattach` to bind the serial port to Line Discipline 29.

**Manual Method:**
```bash
# 1. Configure port (optional, driver does this, but good for safety)
sudo stty -F /dev/ttyACM0 9600 raw clocal -echo

# 2. Attach (Keep this terminal open!)
sudo ldattach -d -s 9600 29 /dev/ttyACM0
```

**Automatic Method (udev rule):**
Create `/etc/udev/rules.d/99-arduino.rules`:
```text
ACTION=="add", SUBSYSTEM=="tty", ATTRS{idVendor}=="2341", RUN+="/usr/sbin/ldattach -d -s 9600 29 /dev/%k"
```

### 3. Verify
Check the kernel logs to see data flowing:
```bash
dmesg -w
```
Test the input events:
```bash
sudo evtest
```

## Troubleshooting

**Problem: `ldattach` says "Invalid argument"**
- The serial port is in a "zombie" state. Unplug the Arduino, wait 5 seconds, and replug it.

**Problem: `dmesg` shows "open successful" but no data received**
- Ensure the Arduino is sending the Heartbeat (`.`).
- Ensure `tty->receive_room` is set in the C code (already fixed in this version).
- Ensure `tty_set_termios` is called to force CLOCAL mode.

**Problem: System freezes**
- This usually indicates a memory safety bug. Ensure you are using the version of the code that uses `tty->disc_data` and **not** global variables.

## License
GPL
